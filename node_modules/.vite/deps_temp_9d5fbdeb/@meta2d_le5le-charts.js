import "./chunk-RDEAKAAS.js";
import {
  getFont
} from "./chunk-LA4BMH4O.js";
import "./chunk-BKDDKEDW.js";

// node_modules/@meta2d/le5le-charts/src/normalizedAxis.js
var maxDecimal = 15;
function fixedNum(num, decimal = maxDecimal) {
  let str = "" + num;
  if (str.indexOf(".") >= 0)
    str = Number.parseFloat(str).toFixed(decimal);
  return Number.parseFloat(str);
}
function numberValid(num) {
  return typeof num === "number" && Number.isFinite(num);
}
function scaleCompute(option) {
  option = {
    max: null,
    min: null,
    splitNumber: 4,
    // splitNumber建议取4或者5等这种容易被整除的数字
    symmetrical: false,
    deviation: false,
    preferZero: false,
    ...option
  };
  const magics = [
    10,
    15,
    20,
    25,
    30,
    40,
    50,
    60,
    70,
    80,
    90,
    100,
    150
  ];
  let { max: dataMax, min: dataMin, splitNumber, symmetrical, deviation, preferZero } = option;
  if (!numberValid(dataMax) || !numberValid(dataMin) || dataMax < dataMin) {
    return { splitNumber };
  } else if (dataMax === dataMin && dataMax === 0) {
    return {
      max: fixedNum(magics[0] * splitNumber),
      min: dataMin,
      interval: magics[0],
      splitNumber
    };
  } else if (dataMax === dataMin) {
    preferZero = true;
  }
  if (!numberValid(splitNumber) || splitNumber <= 0)
    splitNumber = 4;
  if (preferZero && dataMax * dataMin > 0) {
    if (dataMax < 0)
      dataMax = 0;
    else
      dataMin = 0;
  }
  const tempGap = (dataMax - dataMin) / splitNumber;
  let multiple = Math.floor(Math.log10(tempGap) - 1);
  multiple = Math.pow(10, multiple);
  const tempStep = tempGap / multiple;
  let expectedStep = magics[0] * multiple;
  let storedMagicsIndex = -1;
  let index;
  for (index = 0; index < magics.length; index++) {
    if (magics[index] > tempStep) {
      expectedStep = magics[index] * multiple;
      break;
    }
  }
  let axisMax = dataMax;
  let axisMin = dataMin;
  function countDegree(step) {
    axisMax = parseInt("" + (dataMax / step + 1)) * step;
    axisMin = parseInt("" + (dataMin / step - 1)) * step;
    if (dataMax === 0)
      axisMax = 0;
    if (dataMin === 0)
      axisMin = 0;
    if (symmetrical && axisMax * axisMin < 0) {
      const tm = Math.max(Math.abs(axisMax), Math.abs(axisMin));
      axisMax = tm;
      axisMin = -tm;
    }
  }
  countDegree(expectedStep);
  if (deviation) {
    return {
      max: fixedNum(axisMax),
      min: fixedNum(axisMin),
      interval: fixedNum(expectedStep),
      splitNumber: Math.round((axisMax - axisMin) / expectedStep)
    };
  } else if (!symmetrical || axisMax * axisMin > 0) {
    let tempSplitNumber;
    out:
      do {
        tempSplitNumber = Math.round((axisMax - axisMin) / expectedStep);
        if ((index - storedMagicsIndex) * (tempSplitNumber - splitNumber) < 0) {
          while (tempSplitNumber < splitNumber) {
            if (axisMin - dataMin <= axisMax - dataMax && axisMin !== 0 || axisMax === 0) {
              axisMin -= expectedStep;
            } else {
              axisMax += expectedStep;
            }
            tempSplitNumber++;
            if (tempSplitNumber === splitNumber)
              break out;
          }
        }
        if (index >= magics.length - 1 || index <= 0 || tempSplitNumber === splitNumber)
          break;
        storedMagicsIndex = index;
        if (tempSplitNumber > splitNumber)
          expectedStep = magics[++index] * multiple;
        else
          expectedStep = magics[--index] * multiple;
        countDegree(expectedStep);
      } while (tempSplitNumber !== splitNumber);
  }
  axisMax = fixedNum(axisMax);
  axisMin = fixedNum(axisMin);
  const interval = fixedNum((axisMax - axisMin) / splitNumber);
  return {
    max: axisMax,
    min: axisMin,
    interval,
    splitNumber
  };
}

// node_modules/@meta2d/le5le-charts/src/coordinateAxis.js
function coordinateAxis(ctx, pen) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let r = w / 2;
  let scale = pen.calculative.canvas.store.data.scale;
  let series = [];
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  let collection_data = [];
  for (let i = 0; i < series.length; i++) {
    collection_data = collection_data.concat(series[i]);
  }
  let initOption = {
    max: Math.max.apply(null, collection_data),
    min: Math.min.apply(null, collection_data),
    splitNumber: 5
  };
  let normalizedOption = scaleCompute(initOption);
  let num = pen.echarts ? pen.echarts.option.xAxis.data.length : pen.xAxisData.length;
  ctx.beginPath();
  ctx.strokeStyle = "#BFBFBF";
  ctx.lineWidth = 6 * scale;
  ctx.lineCap = "butt";
  let dash = (w - 1 * (num + 1)) / num;
  ctx.setLineDash([1, dash]);
  ctx.moveTo(x, y + h + 3 * scale);
  ctx.lineTo(x + w, y + h + 3 * scale);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  ctx.lineWidth = 1 * scale;
  ctx.setLineDash([]);
  ctx.moveTo(x, y + h);
  ctx.lineTo(x + w, y + h);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = "#BFBFBF";
  ctx.strokeStyle = "#E9E9E9";
  ctx.setLineDash([2, 2]);
  let fontOptions = {
    fontStyle: ((_b = (_a = pen.yAxis) == null ? void 0 : _a.axisLabel) == null ? void 0 : _b.fontStyle) || pen.fontStyle,
    textDecoration: (_d = (_c = pen.yAxis) == null ? void 0 : _c.axisLabel) == null ? void 0 : _d.textDecoration,
    fontWeight: ((_f = (_e = pen.yAxis) == null ? void 0 : _e.axisLabel) == null ? void 0 : _f.fontWeight) || pen.fontWeight,
    fontFamily: ((_h = (_g = pen.yAxis) == null ? void 0 : _g.axisLabel) == null ? void 0 : _h.fontFamily) || pen.fontFamily,
    fontSize: ((_j = (_i = pen.yAxis) == null ? void 0 : _i.axisLabel) == null ? void 0 : _j.fontSize) || pen.fontSize,
    lineHeight: ((_l = (_k = pen.yAxis) == null ? void 0 : _k.axisLabel) == null ? void 0 : _l.lineHeight) || pen.lineHeight
  };
  ctx.fillStyle = ((_n = (_m = pen.yAxis) == null ? void 0 : _m.axisLabel) == null ? void 0 : _n.fontColor) || pen.color;
  for (let i = 0; i < normalizedOption.splitNumber + 1; i++) {
    let temH = i * h / normalizedOption.splitNumber;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.font = getFont(fontOptions);
    ctx.fillText(normalizedOption.max - i * normalizedOption.interval + "", x - 10 * scale, y + temH);
    ctx.fill();
    if (i < normalizedOption.splitNumber) {
      ctx.beginPath();
      ctx.moveTo(x, y + temH);
      ctx.lineTo(x + w, y + temH);
      ctx.stroke();
    }
  }
  ctx.closePath();
  ctx.beginPath();
  ctx.strokeStyle = "#BFBFBF";
  let xData = pen.echarts ? pen.echarts.option.xAxis.data : pen.xAxisData;
  let xdataX = 0;
  for (let i = 0; i < xData.length; i++) {
    xdataX = x + (1 + dash / 2) + (dash + 1) * i;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    let fontOptions2 = {
      fontStyle: ((_p = (_o = pen.xAxis) == null ? void 0 : _o.axisLabel) == null ? void 0 : _p.fontStyle) || pen.calculative.fontStyle,
      textDecoration: (_r = (_q = pen.xAxis) == null ? void 0 : _q.axisLabel) == null ? void 0 : _r.textDecoration,
      fontWeight: ((_t = (_s = pen.xAxis) == null ? void 0 : _s.axisLabel) == null ? void 0 : _t.fontWeight) || pen.calculative.fontWeight,
      fontFamily: ((_v = (_u = pen.xAxis) == null ? void 0 : _u.axisLabel) == null ? void 0 : _v.fontFamily) || pen.calculative.fontFamily,
      fontSize: ((_x = (_w = pen.xAxis) == null ? void 0 : _w.axisLabel) == null ? void 0 : _x.fontSize) || pen.calculative.fontSize,
      lineHeight: ((_z = (_y = pen.xAxis) == null ? void 0 : _y.axisLabel) == null ? void 0 : _z.lineHeight) || pen.calculative.lineHeight
    };
    ctx.font = getFont(fontOptions2);
    ctx.fillStyle = ((_B = (_A = pen.xAxis) == null ? void 0 : _A.axisLabel) == null ? void 0 : _B.fontColor) || pen.calculative.color;
    ctx.fillText(xData[i], xdataX, y + h + 10 * scale);
    ctx.fill();
  }
  ctx.closePath();
  ctx.setLineDash([]);
  return { dash, normalizedOption };
}

// node_modules/@meta2d/le5le-charts/src/common.js
function getValidValue(num, value) {
  if (isNaN(num)) {
    return;
  }
  if (value === -1) {
    return num;
  }
  return Math.round(Number(num) * 1e3) / 1e3;
}
var ReplaceMode;
(function(ReplaceMode2) {
  ReplaceMode2[ReplaceMode2["Add"] = 0] = "Add";
  ReplaceMode2[ReplaceMode2["Replace"] = 1] = "Replace";
  ReplaceMode2[ReplaceMode2["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));

// node_modules/@meta2d/le5le-charts/src/lineChart.js
function lineChart(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue;
  }
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let scale = pen.calculative.canvas.store.data.scale;
  let series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = [
      "#1890ff",
      "#2FC25B",
      "#FACC14",
      "#c23531",
      "#2f4554",
      "#61a0a8",
      "#d48265"
    ];
  }
  let coordinate = coordinateAxis(ctx, pen);
  let dash = coordinate.dash;
  let normalizedOption = coordinate.normalizedOption;
  const smooth = (pen.echarts ? pen.echarts.option.series[0].smooth : pen.smooth) ? true : false;
  let coordinateValue = [];
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  for (let j = 0; j < series.length; j++) {
    ctx.beginPath();
    let data = series[j];
    ctx.strokeStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    let currentX = x + (1 + dash / 2);
    let currentY = y + h - (data[0] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
    ctx.moveTo(currentX, currentY);
    coordinateValue.push({ x: currentX, y: currentY });
    if (smooth) {
      if (data.length <= 2) {
        for (let i = 1; i < data.length; i++) {
          currentX = x + (1 + dash / 2) + (dash + 1) * i;
          currentY = y + h - (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          ctx.lineTo(currentX, currentY);
          coordinateValue.push({ x: currentX, y: currentY });
        }
      } else {
        let cAx, cAy, cBx, cBy;
        data.forEach((item, index) => {
          currentX = x + (1 + dash / 2) + (dash + 1) * index;
          currentY = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let last1x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
          let last1y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let before1x = x + (1 + dash / 2) + (dash + 1) * (index - 1);
          let before1y = y + h - (data[index - 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          let last2x = x + (1 + dash / 2) + (dash + 1) * (index + 2);
          let last2y = y + h - (data[index + 2] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          if (index === 0) {
            before1x = x + (1 + dash / 2) + (dash + 1) * index;
            before1y = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          } else if (index === data.length - 2) {
            last2x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
            last2y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          }
          coordinateValue.push({ x: currentX, y: currentY });
          cAx = currentX + (last1x - before1x) / 4;
          cAy = currentY + (last1y - before1y) / 4;
          cBx = last1x - (last2x - currentX) / 4;
          cBy = last1y - (last2y - currentY) / 4;
          ctx.bezierCurveTo(cAx, cAy, cBx, cBy, last1x, last1y);
        });
      }
    } else {
      for (let i = 1; i < data.length; i++) {
        currentX = x + (1 + dash / 2) + (dash + 1) * i;
        currentY = y + h - (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
        ctx.lineTo(currentX, currentY);
        coordinateValue.push({ x: currentX, y: currentY });
      }
    }
    ctx.stroke();
    ctx.closePath();
    ctx.save();
    coordinateValue.forEach((item, index) => {
      ctx.beginPath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2 * scale;
      ctx.arc(item.x, item.y, 4 * scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
    });
    ctx.restore();
    coordinateValue = [];
  }
}
function beforeValue(pen, value) {
  if (value.xAxisData || value.data || !value.dataX && !value.dataY) {
    return value;
  }
  const _xAxisData = pen.xAxisData;
  const _data = pen.data;
  const replaceMode = pen.replaceMode;
  let xAxisData = [];
  let data = [];
  if (!replaceMode) {
    xAxisData = [..._xAxisData, ...value.dataX];
    _data.forEach((item, index) => {
      let _item = [...item, ...value.dataY[index]];
      data.push(_item);
    });
  } else if (replaceMode === ReplaceMode.Replace) {
    value.dataX.forEach((item, i) => {
      let _index = _xAxisData.indexOf(item);
      _data.forEach((d, index) => {
        d[_index] = value.dataY[index][i];
      });
    });
    xAxisData = _xAxisData;
    data = _data;
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    xAxisData = value.dataX;
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, { xAxisData, data });
}

// node_modules/@meta2d/le5le-charts/src/pieChart.js
function pieChart(ctx, pen) {
  var _a, _b;
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue2;
  }
  let scale = pen.calculative.canvas.store.data.scale;
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  const isEcharts = pen.echarts ? true : false;
  if (pen.echarts) {
    if (!pen.echarts.option.color) {
      pen.echarts.option.color = [
        "#1890ff",
        "#2FC25B",
        "#FACC14",
        "#c23531",
        "#2f4554",
        "#61a0a8",
        "#d48265"
      ];
    }
    pen.chartsColor = pen.echarts.option.color;
  } else {
    if (!pen.chartsColor) {
      pen.chartsColor = [
        "#1890ff",
        "#2FC25B",
        "#FACC14",
        "#c23531",
        "#2f4554",
        "#61a0a8",
        "#d48265"
      ];
    }
  }
  const seriesArray = isEcharts ? pen.echarts.option.series : pen.data;
  let beforeSeriesLength = 0;
  for (let ser = 0; ser < seriesArray.length; ser++) {
    let series = seriesArray[ser];
    let r = w / 2;
    if (h < w) {
      r = h / 2;
    }
    const centerX = x + w / 2;
    const centerY = y + h / 2;
    let sum = 0;
    if (isEcharts) {
      sum = series.data.reduce((prev, curr) => {
        return prev + curr.value;
      }, 0);
    } else {
      sum = series.reduce((prev, curr) => {
        return prev + curr.value;
      }, 0);
    }
    const fromR = r * parseFloat(isEcharts ? series.radius[0] : pen.chartsRadius[ser][0]) / 100;
    const toR = r * parseFloat(isEcharts ? series.radius[1] : pen.chartsRadius[ser][1]) / 100;
    if (fromR > toR) {
      return;
    }
    let beforeAngle = 0;
    let afterAngle = 0;
    ctx.strokeStyle = isEcharts ? ((_a = series.itemStyle) == null ? void 0 : _a.borderColor) || "#fff" : "#fff";
    ctx.lineWidth = (isEcharts ? ((_b = series.itemStyle) == null ? void 0 : _b.borderWidth) || 2 : 2) * scale;
    const data = isEcharts ? series.data : series;
    data.forEach((item, index) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
      afterAngle += Math.PI * 2 * item.value / sum;
      ctx.beginPath();
      let colorLength = beforeSeriesLength + index;
      if (colorLength >= pen.chartsColor.length) {
        colorLength = colorLength % pen.chartsColor.length;
      }
      ctx.fillStyle = isEcharts ? pen.echarts.option.color[colorLength] : pen.chartsColor[colorLength];
      ctx.moveTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.arc(centerX, centerY, fromR, -Math.PI / 2 + afterAngle, -Math.PI / 2 + beforeAngle, true);
      ctx.lineTo(centerX + toR * Math.sin(beforeAngle), centerY - toR * Math.cos(beforeAngle));
      ctx.arc(centerX, centerY, toR, -Math.PI / 2 + beforeAngle, -Math.PI / 2 + afterAngle);
      ctx.lineTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
      let centerAngle = (beforeAngle + afterAngle) / 2;
      let temX = centerX + (toR + 10 * scale) * Math.sin(centerAngle);
      let temY = centerY - (toR + 10 * scale) * Math.cos(centerAngle);
      let temFillStyle = ctx.fillStyle;
      if (!series.label) {
        series.label = { position: "outside", show: true };
      }
      if (isEcharts && ["inner", "inside"].includes(series.label.position)) {
        ctx.fillStyle = "#ffffff";
        temX = centerX + (toR - fromR) / 2 * Math.sin(centerAngle);
        temY = centerY - (toR - fromR) / 2 * Math.cos(centerAngle);
      } else if (isEcharts && series.label.position == "outside") {
      }
      if (!series.labelLine) {
        series.labelLine = { show: true };
      }
      if (isEcharts && series.labelLine.show !== false || !isEcharts) {
        ctx.beginPath();
        ctx.strokeStyle = isEcharts ? pen.echarts.option.color[beforeSeriesLength + index] : pen.chartsColor[beforeSeriesLength + index];
        ctx.moveTo(centerX + toR * Math.sin(centerAngle), centerY - toR * Math.cos(centerAngle));
        ctx.lineTo(temX, temY);
      }
      let fontOption = {
        fontStyle: ((_a2 = pen.tickLabel) == null ? void 0 : _a2.fontStyle) || pen.calculative.fontStyle,
        fontWeight: ((_b2 = pen.tickLabel) == null ? void 0 : _b2.fontWeight) || pen.calculative.fontWeight,
        fontFamily: ((_c = pen.tickLabel) == null ? void 0 : _c.fontFamily) || pen.calculative.fontFamily,
        lineHeight: ((_d = pen.tickLabel) == null ? void 0 : _d.lineHeight) || pen.calculative.lineHeight,
        fontSize: (((_e = pen.tickLabel) == null ? void 0 : _e.fontSize) || pen.calculative.fontSize) * scale
      };
      ctx.font = getFont(fontOption);
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      if (centerAngle > Math.PI) {
        if (isEcharts && series.label.position === "outside" || !isEcharts) {
          ctx.textAlign = "end";
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts && (((_g = (_f = pen.tickLabel) == null ? void 0 : _f.labelLine) == null ? void 0 : _g.show) ?? true)) {
          ctx.lineTo(temX - 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && (((_h = pen.tickLabel) == null ? void 0 : _h.show) ?? true)) {
          ctx.fillText(item.name, temX - 5 * scale, temY);
        }
      } else {
        if (isEcharts && series.label.position === "outside" || !isEcharts) {
          ctx.textAlign = "start";
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts) {
          ctx.lineTo(temX + 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && (((_i = pen.tickLabel) == null ? void 0 : _i.show) ?? true)) {
          ctx.fillText(item.name, temX + 5 * scale, temY);
        }
      }
      ctx.stroke();
      ctx.closePath();
      ctx.fillStyle = temFillStyle;
      ctx.strokeStyle = isEcharts ? ((_j = series.itemStyle) == null ? void 0 : _j.borderColor) || "#fff" : "#fff";
      beforeAngle = afterAngle;
    });
    beforeSeriesLength += data.length;
  }
}
function beforeValue2(pen, value) {
  if (value.data || !value.dataX && !value.dataY) {
    return value;
  }
  const _data = pen.data;
  const replaceMode = pen.replaceMode;
  let data = [];
  if (!replaceMode) {
    _data.forEach((item, index) => {
      let _item = [...item, ...value.dataY[index]];
      data.push(_item);
    });
  } else if (replaceMode === ReplaceMode.Replace) {
    value.dataY.forEach((item, index) => {
      item.forEach((_innerItem, _innderIndex) => {
        let _filterItem = _data[index].filter((_i) => _i.name === _innerItem.name);
        if (_filterItem.length > 0) {
          _filterItem[0].value = _innerItem.value;
        }
      });
    });
    data = _data;
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, { data });
}

// node_modules/@meta2d/le5le-charts/src/histogram.js
function histogram(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue;
  }
  let scale = pen.calculative.canvas.store.data.scale;
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = [
      "#1890ff",
      "#2FC25B",
      "#FACC14",
      "#c23531",
      "#2f4554",
      "#61a0a8",
      "#d48265"
    ];
  }
  if (pen.echarts) {
    for (let i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  let coordinate = coordinateAxis(ctx, pen);
  let dash = coordinate.dash;
  let normalizedOption = coordinate.normalizedOption;
  let itemWidth = dash * 4 / 5 / series.length;
  for (let j = 0; j < series.length; j++) {
    ctx.beginPath();
    let data = series[j];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1 * scale;
    let currentX = 0;
    let currentY = 0;
    let currentH = 0;
    for (let i = 0; i < data.length; i++) {
      currentX = x + (1 + 0.1 * dash) + (dash + 1) * i + itemWidth * j;
      currentH = (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
      currentY = y + h - currentH;
      ctx.rect(currentX, currentY, itemWidth - 1, currentH - 1);
      ctx.stroke();
      ctx.fill();
    }
    ctx.closePath();
  }
}

// node_modules/@meta2d/le5le-charts/src/gauge.js
function gauge(ctx, pen) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  if (!pen.onAdd) {
    pen.onAdd = onAdd;
    pen.onDestroy = onDestroy;
    pen.onClick = onclick;
    if (pen.clockInterval) {
      pen.onDestroy(pen);
      pen.onAdd(pen);
    }
  }
  const x = pen.calculative.worldRect.x;
  const y = pen.calculative.worldRect.y;
  const w = pen.calculative.worldRect.width;
  const h = pen.calculative.worldRect.height;
  let scale = pen.calculative.canvas.store.data.scale;
  let basicConfigure = {
    startAngle: 225,
    endAngle: -45,
    min: 0,
    max: 100,
    splitNumber: 10
  };
  if (pen.echarts && pen.echarts.option) {
    let series = pen.echarts.option.series[0];
    pen.startAngle = series.startAngle || basicConfigure.startAngle;
    pen.endAngle = series.endAngle || basicConfigure.endAngle;
    pen.min = series.min || basicConfigure.min;
    pen.max = series.max || basicConfigure.max;
    pen.axisLine = series.axisLine.lineStyle.color;
    pen.unit = series.detail.formatter.replace("{value}", "");
    pen.value = series.data[0].value;
    pen.splitNumber = series.splitNumber || basicConfigure.splitNumber;
  }
  pen = { ...basicConfigure, ...pen };
  let r = w > h ? h / 2 * 9 / 10 : w / 2 * 9 / 10;
  let centerX = x + w / 2;
  let centerY = y + h / 2;
  let value = pen.echarts ? pen.echarts.option.series[0].data[0].value : pen.value;
  let pointColor;
  let gap = pen.startAngle - pen.endAngle;
  let bgColor = pen.background || "#E6EBF8";
  ctx.strokeStyle = bgColor;
  let bgLineWidth = r / 10;
  ctx.lineWidth = bgLineWidth;
  ctx.beginPath();
  ctx.lineCap = "round";
  ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, -pen.endAngle / 180 * Math.PI);
  ctx.stroke();
  ctx.closePath();
  let bili = 0;
  if (pen.axisLine && !pen.isClock) {
    for (let i = pen.axisLine.length - 1; i >= 0; i--) {
      if (pen.axisLine[i][0] * (pen.max - pen.min) < value) {
        bili = pen.axisLine[i][0];
      } else {
        bili = (value - pen.min) / (pen.max - pen.min);
        pointColor = pen.axisLine[i][1];
      }
      ctx.beginPath();
      ctx.strokeStyle = pen.axisLine[i][1];
      ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, (-pen.startAngle + bili * gap) / 180 * Math.PI);
      ctx.stroke();
      ctx.closePath();
    }
  }
  ctx.lineCap = "butt";
  let dashWidth = 2 * scale;
  let mainR = r - bgLineWidth;
  if (mainR < 0) {
    mainR = 0;
  }
  let arcLength = gap / 180 * Math.PI * mainR;
  let dash = (arcLength - dashWidth * pen.splitNumber) / pen.splitNumber;
  let offsetAngle = gap / 180 * Math.PI * dashWidth / 2 / arcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || "#999999";
  ctx.lineWidth = r / 20;
  ctx.setLineDash([dashWidth, dash]);
  ctx.arc(centerX, centerY, mainR, -pen.startAngle / 180 * Math.PI - offsetAngle, -pen.endAngle / 180 * Math.PI + offsetAngle);
  ctx.stroke();
  ctx.closePath();
  let fromDashWidth = 1 * scale;
  let fromR = r - bgLineWidth;
  if (fromR < 0) {
    fromR = 0;
  }
  let fromArcLength = gap / 180 * Math.PI * fromR;
  let fromDash = (fromArcLength - fromDashWidth * 5 * pen.splitNumber) / 5 / pen.splitNumber;
  let fromOffsetAngle = gap / 180 * Math.PI * fromDashWidth / 2 / fromArcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || "#999999";
  ctx.lineWidth = r / 40;
  ctx.setLineDash([fromDashWidth, fromDash]);
  ctx.arc(centerX, centerY, fromR, -pen.startAngle / 180 * Math.PI - fromOffsetAngle, -pen.endAngle / 180 * Math.PI + fromOffsetAngle);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  let valueGap = pen.max - pen.min;
  let interval = valueGap / pen.splitNumber;
  let fontOption = {
    fontStyle: ((_a = pen.tickLabel) == null ? void 0 : _a.fontStyle) || pen.calculative.fontStyle,
    textDecoration: ((_b = pen.tickLabel) == null ? void 0 : _b.textDecoration) || pen.textDecoration,
    fontWeight: ((_c = pen.tickLabel) == null ? void 0 : _c.fontWeight) || pen.calculative.fontWeight,
    fontFamily: ((_d = pen.tickLabel) == null ? void 0 : _d.fontFamily) || pen.calculative.fontFamily,
    fontSize: (((_e = pen.tickLabel) == null ? void 0 : _e.fontSize) || pen.calculative.fontSize) * scale,
    lineHeight: ((_f = pen.tickLabel) == null ? void 0 : _f.lineHeight) || pen.calculative.lineHeight
  };
  ctx.font = getFont(fontOption);
  let textR = r - bgLineWidth - r / 20;
  for (let i = 0; i <= pen.splitNumber; i++) {
    if (Math.abs(pen.startAngle) + Math.abs(pen.endAngle) === 360) {
      if (i == 0)
        continue;
    }
    let angle = pen.startAngle - interval * i / valueGap * gap;
    let width = Math.cos(angle / 180 * Math.PI);
    let height = Math.sin(angle / 180 * Math.PI);
    ctx.fillStyle = ((_g = pen.tickLabel) == null ? void 0 : _g.color) || "#999999";
    if (width > 0.02) {
      ctx.textAlign = "end";
    } else if (width < -0.02) {
      ctx.textAlign = "start";
    } else {
      ctx.textAlign = "center";
    }
    if (height > 0.02) {
      ctx.textBaseline = "top";
    } else if (height < -0.02) {
      ctx.textBaseline = "bottom";
    } else {
      ctx.textBaseline = "middle";
    }
    ctx.fillText(getValidValue(interval * i + pen.min, 1), centerX + textR * width, centerY - textR * height);
    ctx.fill();
  }
  ctx.closePath();
  let pointNum = 1;
  let valueArray = ["value"];
  if (pen.isClock) {
    pointNum = 3;
    valueArray = ["hourvalue", "minutevalue", "secondvalue"];
  }
  if (pen.isClock) {
    for (let i = 0; i < pointNum; i++) {
      let currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
      if (i > 0) {
        currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max * 5 - pen.min) * gap) / 180 * Math.PI;
      }
      let pointerR = 4 / 5 * r;
      if (valueArray[i] === "hourvalue") {
        pointerR = 3 / 5 * r;
      }
      if (valueArray[i] === "minutevalue") {
        pointerR = 3.5 / 5 * r;
      }
      let pointerHalfW = r * 1 / 40;
      ctx.beginPath();
      ctx.setLineDash([]);
      ctx.lineWidth = r / (i + 1) / 20;
      ctx.strokeStyle = pen.color || "#999999";
      ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
      ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
      ctx.stroke();
    }
  } else {
    let currentAngle = (pen.startAngle - (value - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
    let pointerR = 4 / 5 * r;
    let pointerHalfW = r * 1 / 40;
    ctx.beginPath();
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.fillStyle = pointColor;
    ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle - Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle - Math.PI / 2));
    ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle + Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle + Math.PI / 2));
    ctx.lineTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.fill();
  }
  ctx.beginPath();
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  let titleOption = {
    fontStyle: ((_h = pen.titleLabel) == null ? void 0 : _h.fontStyle) || pen.calculative.fontStyle,
    textDecoration: ((_i = pen.titleLabel) == null ? void 0 : _i.textDecoration) || pen.textDecoration,
    fontWeight: ((_j = pen.titleLabel) == null ? void 0 : _j.fontWeight) || pen.calculative.fontWeight,
    fontFamily: ((_k = pen.titleLabel) == null ? void 0 : _k.fontFamily) || pen.calculative.fontFamily,
    fontSize: (((_l = pen.titleLabel) == null ? void 0 : _l.fontSize) || pen.calculative.fontSize) * scale,
    lineHeight: ((_m = pen.titleLabel) == null ? void 0 : _m.lineHeight) || pen.calculative.lineHeight
  };
  ctx.font = getFont(titleOption);
  ctx.fillStyle = ((_n = pen.titleLabel) == null ? void 0 : _n.color) || pointColor;
  if (pen.isClock) {
    ctx.fillText(("0" + parseInt(pen.hourvalue)).slice(-2) + ":" + ("0" + parseInt(pen.minutevalue)).slice(-2) + ":" + ("0" + parseInt(pen.secondvalue)).slice(-2), centerX, centerY + r / 2);
  } else {
    ctx.fillText(value + " " + (pen.unit || ""), centerX, centerY + r / 2);
  }
  ctx.fill();
  if (pen.isClock) {
    ctx.beginPath();
    ctx.fillStyle = pen.color || "#999999";
    ctx.strokeStyle = "#ffffff";
    ctx.arc(centerX, centerY, r / 20, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
}
function onAdd(pen) {
  if (pen.isClock) {
    pen.clockInterval = setInterval(() => {
      let date = /* @__PURE__ */ new Date();
      let second = date.getSeconds();
      let minute = date.getMinutes() + second / 60;
      let hour = date.getHours() % 12 + minute / 60;
      pen.calculative.canvas.parent.setValue({
        id: pen.id,
        hourvalue: hour,
        minutevalue: minute,
        secondvalue: second
      }, {
        render: true,
        doEvent: false
      });
    }, 1e3);
  } else {
    const tem = pen.value;
    pen.value = 0;
    pen.frames = [
      {
        duration: 2e3,
        value: tem
      }
    ];
    pen.calculative.canvas.parent.startAnimate(pen.id);
    setTimeout(() => {
      pen.value = tem;
    }, 1e3);
  }
}
function onDestroy(pen) {
  if (pen.clockInterval) {
    clearInterval(pen.clockInterval);
    pen.clockInterval = void 0;
  }
}
function onclick(pen) {
  if (pen.isClock) {
    pen.onDestroy(pen);
    pen.onAdd(pen);
  }
}

// node_modules/@meta2d/le5le-charts/src/register.js
function chartsPens() {
  return {
    lineChart,
    histogram,
    pieChart,
    gauge
  };
}
export {
  beforeValue,
  chartsPens,
  gauge,
  histogram,
  lineChart,
  pieChart
};
//# sourceMappingURL=@meta2d_le5le-charts.js.map
